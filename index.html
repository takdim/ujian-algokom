<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ALGOKOM Demo - Fibonacci (C Backend) & Bilinear Interpolation</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
      }

      h1 {
        text-align: center;
        color: white;
        margin-bottom: 30px;
        font-size: 2.5em;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .demo-section {
        background: white;
        border-radius: 15px;
        padding: 30px;
        margin-bottom: 30px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      }

      h2 {
        color: #667eea;
        margin-bottom: 20px;
        border-bottom: 3px solid #667eea;
        padding-bottom: 10px;
      }

      .input-group {
        margin-bottom: 20px;
      }

      label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
        color: #333;
      }

      input[type="number"],
      input[type="range"],
      select {
        width: 100%;
        padding: 10px;
        border: 2px solid #ddd;
        border-radius: 5px;
        font-size: 16px;
      }

      input[type="range"] {
        padding: 0;
      }

      button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 12px 30px;
        border-radius: 25px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: transform 0.2s;
        margin-right: 10px;
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
      }

      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }

      .results {
        margin-top: 20px;
        padding: 20px;
        background: #f8f9fa;
        border-radius: 10px;
        border-left: 4px solid #667eea;
      }

      .results h3 {
        color: #667eea;
        margin-bottom: 10px;
      }

      .result-item {
        margin: 10px 0;
        padding: 15px;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      .result-label {
        font-weight: bold;
        color: #667eea;
        font-size: 16px;
        margin-bottom: 8px;
      }

      .result-details {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 10px;
        margin-top: 8px;
      }

      .detail-item {
        background: #f8f9fa;
        padding: 8px;
        border-radius: 5px;
      }

      .detail-label {
        font-size: 12px;
        color: #666;
        margin-bottom: 3px;
      }

      .detail-value {
        font-size: 14px;
        font-weight: bold;
        color: #333;
      }

      .time-badge {
        background: #28a745;
        color: white;
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 12px;
        margin-left: 10px;
      }

      .speedup-badge {
        background: #17a2b8;
        color: white;
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 12px;
        margin-left: 10px;
      }

      .loading {
        text-align: center;
        padding: 20px;
        color: #667eea;
        font-size: 16px;
      }

      .loading::after {
        content: "...";
        animation: dots 1.5s steps(4, end) infinite;
      }

      @keyframes dots {
        0%,
        20% {
          content: ".";
        }
        40% {
          content: "..";
        }
        60% {
          content: "...";
        }
        80%,
        100% {
          content: "";
        }
      }

      .error {
        background: #f8d7da;
        color: #721c24;
        padding: 15px;
        border-radius: 8px;
        border-left: 4px solid #dc3545;
      }

      .info-box {
        background: #e3f2fd;
        border-left: 4px solid #2196f3;
        padding: 15px;
        margin: 15px 0;
        border-radius: 5px;
      }

      .info-box strong {
        color: #1976d2;
      }

      .c-badge {
        background: #5c6ac4;
        color: white;
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 11px;
        font-weight: bold;
        margin-left: 8px;
      }

      .openmp-badge {
        background: #ff6b6b;
        color: white;
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 11px;
        font-weight: bold;
        margin-left: 8px;
      }

      .cilk-badge {
        background: #ff9ff3;
        color: white;
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 11px;
        font-weight: bold;
        margin-left: 8px;
      }

      canvas {
        border: 2px solid #ddd;
        border-radius: 10px;
        margin: 10px 5px;
        background: #f8f9fa;
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }

      .comparison {
        text-align: center;
      }

      .comparison h4 {
        color: #667eea;
        margin: 10px 0;
        font-size: 16px;
      }

      .comparison img {
        max-width: 100%;
        height: auto;
        display: block;
        border-radius: 8px;
      }

      #originalImg {
        width: 300px;
        height: auto;
      }

      #upscaledImgSerial {
        width: 480px;
        height: auto;
      }

      #upscaledImgParallel {
        width: 480px;
        height: auto;
      }

      .comparison img {
        max-width: 100%;
        height: auto;
        border-radius: 8px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>
        üéØ ALGOKOM Interactive Demo <span class="c-badge">C Backend</span>
      </h1>

      <!-- NAVIGATION BUTTONS -->
      <div
        style="
          display: flex;
          gap: 10px;
          justify-content: center;
          margin-bottom: 30px;
          flex-wrap: wrap;
        "
      >
        <a href="fibonacci-details.html" style="text-decoration: none">
          <button
            style="
              background: linear-gradient(135deg, #f57f17 0%, #ff6b6b 100%);
              margin: 0;
            "
          >
            üìö Fibonacci Methods Explained
          </button>
        </a>
        <a href="bilinear-details.html" style="text-decoration: none">
          <button
            style="
              background: linear-gradient(135deg, #17a2b8 0%, #20c997 100%);
              margin: 0;
            "
          >
            üé® Bilinear Interpolation Details
          </button>
        </a>
      </div>

      <!-- FIBONACCI SECTION -->
      <div class="demo-section">
        <h2>üìä Fibonacci Calculator - OpenMP & OpenCilk Parallel Computing</h2>

        <div class="info-box">
          <strong>üöÄ Powered by C, OpenMP, & OpenCilk!</strong><br />
          Program ini menggunakan backend C dengan **dua parallel computing
          models**: OpenMP (GCC) dan OpenCilk (work-stealing scheduler). Pilih
          OpenMP saja, OpenCilk saja, atau jalankan keduanya sekaligus untuk
          melihat perbandingan performanya.
        </div>

        <div class="input-group">
          <label for="fibN">Enter n (0-45):</label>
          <input type="number" id="fibN" min="0" max="45" value="35" />
        </div>

        <div class="input-group">
          <label for="fibMode">Mode:</label>
          <select id="fibMode">
            <option value="both" selected>
              üî∂ OpenMP + üî∑ OpenCilk (run both)
            </option>
            <option value="openmp">üî∂ OpenMP only</option>
            <option value="cilk">üî∑ OpenCilk only</option>
          </select>
        </div>

        <button onclick="calculateFibonacci()" id="calculateBtn">
          Calculate (C Backend)
        </button>

        <!-- FIBONACCI CODE (C BACKEND) -->
        <details
          style="
            margin: 15px 0 10px 0;
            background: #f5f7fb;
            border-radius: 10px;
            padding: 16px;
            border: 1px solid #e2e6f0;
          "
        >
          <summary style="cursor: pointer; font-weight: bold; color: #667eea">
            üìú Lihat Kode C Backend (Fibonacci OpenMP & OpenCilk)
          </summary>
          <div style="margin-top: 12px">
            <div style="font-size: 0.9em; color: #374151; margin-bottom: 10px">
              Kompilasi:
              <code
                >gcc-15 -fopenmp -DUSE_OPENMP -o fib_omp_json
                fibonacci_json.c</code
              >,
              <code
                >&lt;opencilk-clang&gt; -fopencilk -DUSE_CILK -o fib_json_cilk
                fibonacci_json.c</code
              >.
            </div>

            <h5 style="margin: 8px 0; color: #334155">
              1) Baseline & utilitas
            </h5>
            <pre
              style="
                background: #0f172a;
                color: #e5e7eb;
                padding: 12px;
                border-radius: 8px;
                overflow-x: auto;
                font-size: 13px;
                line-height: 1.5;
                border: 1px solid #1f2937;
              "
            ><code>int fib_sequential(int n) {
  if (n < 2) return n;
  return fib_sequential(n - 1) + fib_sequential(n - 2);
}
</code></pre>

            <h5 style="margin: 8px 0; color: #334155">2) OpenMP</h5>
            <pre
              style="
                background: #0f172a;
                color: #e5e7eb;
                padding: 12px;
                border-radius: 8px;
                overflow-x: auto;
                font-size: 13px;
                line-height: 1.5;
                border: 1px solid #1f2937;
              "
            ><code>#ifdef USE_OPENMP
#include &lt;omp.h&gt;
#define CUTOFF 20

int fib_omp_task(int n) {
  if (n < 2) return n;
  if (n < CUTOFF) return fib_sequential(n);
  int x, y;
  #pragma omp task shared(x) { x = fib_omp_task(n - 1); }
  y = fib_omp_task(n - 2);
  #pragma omp taskwait
  return x + y;
}

int fibonacci_openmp_parallel(int n) {
  int res = 0;
  #pragma omp parallel
  { #pragma omp single { res = fib_omp_task(n); } }
  return res;
}
#endif</code></pre>

            <h5 style="margin: 8px 0; color: #334155">3) OpenCilk</h5>
            <pre
              style="
                background: #0f172a;
                color: #e5e7eb;
                padding: 12px;
                border-radius: 8px;
                overflow-x: auto;
                font-size: 13px;
                line-height: 1.5;
                border: 1px solid #1f2937;
              "
            ><code>#ifdef USE_CILK
#include &lt;cilk/cilk.h&gt;
#define CILK_CUTOFF 20

int fib_cilk_task(int n) {
  if (n < 2) return n;
  if (n < CILK_CUTOFF) return fib_sequential(n);
  int x = cilk_spawn fib_cilk_task(n - 1);
  int y = fib_cilk_task(n - 2);
  cilk_sync;
  return x + y;
}

int fibonacci_cilk_parallel(int n) { return fib_cilk_task(n); }
#endif</code></pre>
          </div>
        </details>

        <div class="results" id="fibResults" style="display: none">
          <h3>Results from C Program:</h3>
          <div id="fibOutput"></div>
        </div>

        <div
          class="info-box"
          style="background: #d1ecf1; border-left-color: #17a2b8"
        >
          <strong style="color: #0c5460">üí° Available Implementations:</strong
          ><br />
          <strong>üî∂ OpenMP Mode:</strong> Menggunakan GCC dengan fork-join task
          model<br />
          ‚Ä¢ Sequential: Baseline single-threaded<br />
          ‚Ä¢ OpenMP Serial: Framework tanpa parallelization (overhead
          measurement)<br />
          ‚Ä¢ OpenMP Parallel: Multi-threaded dengan task parallelism<br />
          <br />
          <strong>üî∑ OpenCilk Mode:</strong> Menggunakan OpenCilk compiler
          dengan work-stealing scheduler<br />
          ‚Ä¢ Cilk Serial: Single-threaded tanpa spawn<br />
          ‚Ä¢ Cilk Parallel: Work-stealing task parallelism<br />
          <br />
          <strong>ÔøΩ Key Metrics:</strong><br />
          ‚Ä¢ <strong>Speedup</strong>: Waktu Sequential / Waktu Parallel<br />
          ‚Ä¢ <strong>Efficiency</strong>: (Speedup / Jumlah Thread) √ó 100%<br />
          ‚Ä¢ <strong>Cutoff</strong>: Threshold untuk menghindari overhead task
          creation<br />
        </div>

        <!-- Algorithm Explanations -->
        <div style="margin-top: 30px">
          <h3 style="color: #667eea; margin-bottom: 15px">
            üìö Parallel Computing Concepts
          </h3>

          <div
            style="
              background: #d4edda;
              padding: 15px;
              border-radius: 8px;
              margin-bottom: 10px;
              border-left: 4px solid #28a745;
            "
          >
            <strong style="color: #155724">Sequential Execution</strong>
            <p style="margin: 8px 0 0 0; color: #333">
              <strong>Cara Kerja:</strong> Satu thread menghitung semua secara
              berurutan<br />
              <strong>Kelebihan:</strong> Simple, predictable, no overhead<br />
              <strong>Kelemahan:</strong> Tidak memanfaatkan multi-core
              processor
            </p>
          </div>

          <div
            style="
              background: #fff3cd;
              padding: 15px;
              border-radius: 8px;
              margin-bottom: 10px;
              border-left: 4px solid #ffc107;
            "
          >
            <strong style="color: #856404">OpenMP Serial</strong>
            <p style="margin: 8px 0 0 0; color: #333">
              <strong>Cara Kerja:</strong> Menggunakan OpenMP framework tapi
              tanpa task parallelism<br />
              <strong>Tujuan:</strong> Mengukur overhead dari OpenMP runtime<br />
              <strong>Overhead:</strong> Biasanya 0-2% (sangat minimal)
            </p>
          </div>

          <div
            style="
              background: #e7d4f5;
              padding: 15px;
              border-radius: 8px;
              border-left: 4px solid #7b42bc;
            "
          >
            <strong style="color: #4a148c">OpenMP Parallel (Task-Based)</strong>
            <p style="margin: 8px 0 0 0; color: #333">
              <strong>Cara Kerja:</strong> Fork-Join model dengan task
              dependency<br />
              <strong>Model:</strong> #pragma omp task untuk spawn parallel
              tasks<br />
              <strong>Cutoff Strategy:</strong> Sequential untuk n < 20
              (menghindari overhead)<br />
              <strong>Keunggulan:</strong> Load balancing otomatis, skalabilitas
              baik
            </p>
          </div>

          <div
            style="
              background: #f8d7da;
              padding: 15px;
              border-radius: 8px;
              border-left: 4px solid #dc3545;
            "
          >
            <strong style="color: #721c24"
              >Cilk Parallel (Work-Stealing)</strong
            >
            <p style="margin: 8px 0 0 0; color: #333">
              <strong>Cara Kerja:</strong> Spawn tasks dengan work-stealing
              scheduler<br />
              <strong>Model:</strong> cilk_spawn untuk spawn parallel tasks<br />
              <strong>Synchronization:</strong> cilk_sync untuk wait tasks<br />
              <strong>Cutoff Strategy:</strong> Sequential untuk n < 20
              (menghindari overhead)<br />
              <strong>Work-Stealing Scheduler:</strong> Idle threads mencuri
              task dari busy threads<br />
              <strong>Keunggulan:</strong> Optimal load balancing,
              cache-friendly, minimal overhead<br />
              <strong>Formula:</strong> T_P ‚âà W/P + D (W=total work,
              P=processors, D=depth)
            </p>
          </div>
        </div>
      </div>

      <!-- BILINEAR INTERPOLATION SECTION - C BACKEND -->
      <div class="demo-section">
        <h2>üé® Bilinear Interpolation - Image Upscaling (C + OpenMP)</h2>

        <div
          style="
            margin-bottom: 25px;
            padding: 20px;
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
            border-radius: 10px;
            border-left: 5px solid #667eea;
          "
        >
          <h3 style="color: #667eea; margin-bottom: 10px">
            üìñ Bilinear Interpolation untuk Image Upscaling
          </h3>
          <p style="color: #333; line-height: 1.8; margin-bottom: 10px">
            <strong>Bilinear Interpolation</strong> adalah teknik image
            processing untuk memperbesar (zoom) gambar dengan mengestimasi nilai
            pixel baru berdasarkan 4 pixel terdekat dari image original.
            Hasilnya lebih smooth dibanding Nearest Neighbor.
          </p>
        </div>

        <div class="info-box">
          <strong>üöÄ Powered by C & OpenMP!</strong><br />
          Program C backend melakukan real image resizing dengan bilinear
          interpolation menggunakan OpenMP untuk parallel processing.
        </div>

        <div class="input-group">
          <label>Image File:</label>
          <select id="imageFile" onchange="updateImageInfo()">
            <option value="gantrycrane.png" selected>
              Gantry Crane (Default)
            </option>
            <option value="custom">Custom File (path)</option>
          </select>
          <input
            type="text"
            id="customImagePath"
            placeholder="Enter image path (PNG)"
            style="display: none; margin-top: 10px"
          />
        </div>

        <div class="input-group">
          <label>Scaling Factor (1.5x - 4.0x):</label>
          <input
            type="range"
            id="scalingFactor"
            min="1.5"
            max="4.0"
            step="0.5"
            value="2.0"
            oninput="updateScalingInfo()"
          />
          <span id="scalingVal">2.0</span>x
        </div>

        <div
          id="imageInfo"
          style="
            display: none;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
          "
        >
          <div>
            <strong>Original Size:</strong> <span id="origWidth">-</span> √ó
            <span id="origHeight">-</span> pixels
          </div>
          <div>
            <strong>Upscaled Size:</strong> <span id="newWidth">-</span> √ó
            <span id="newHeight">-</span> pixels
          </div>
          <div>
            <strong>Estimated Time:</strong>
            <span id="estimatedTime">-</span> ms
          </div>
        </div>

        <button onclick="processImageBilinear()" id="processBtn">
          üöÄ Process with C Backend (Serial & Parallel Auto)
        </button>

        <div class="results" id="bilinearResults" style="display: none">
          <h3>Image Processing Results:</h3>
          <div id="bilinearOutput"></div>
        </div>

        <div
          class="grid"
          id="imageComparison"
          style="display: none; margin-top: 30px"
        >
          <div class="comparison">
            <h4>Original Image</h4>
            <img
              id="originalImg"
              src=""
              alt="Original"
              style="
                border: 2px solid #ddd;
                border-radius: 8px;
                max-width: 100%;
                height: auto;
              "
            />
            <p
              style="font-size: 12px; color: #666; margin-top: 5px"
              id="origSize"
            >
              -
            </p>
          </div>
          <div class="comparison">
            <h4>Serial Result</h4>
            <img
              id="upscaledImgSerial"
              src=""
              alt="Upscaled Serial"
              style="
                border: 2px solid #28a745;
                border-radius: 8px;
                max-width: 100%;
                height: auto;
              "
            />
            <p
              style="
                font-size: 12px;
                color: #28a745;
                margin-top: 5px;
                font-weight: bold;
              "
              id="serialTime"
            >
              -
            </p>
          </div>
          <div class="comparison">
            <h4>Parallel Result (8-Thread)</h4>
            <img
              id="upscaledImgParallel"
              src=""
              alt="Upscaled Parallel"
              style="
                border: 2px solid #ff6b6b;
                border-radius: 8px;
                max-width: 100%;
                height: auto;
              "
            />
            <p
              style="
                font-size: 12px;
                color: #ff6b6b;
                margin-top: 5px;
                font-weight: bold;
              "
              id="parallelTime"
            >
              -
            </p>
          </div>
        </div>

        <details
          style="
            margin-top: 25px;
            background: #f5f7fb;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #e2e6f0;
          "
        >
          <summary style="cursor: pointer; font-weight: bold; color: #667eea">
            üìú Lihat Kode C Backend (Serial & OpenMP Parallel)
          </summary>
          <div style="margin-top: 12px">
            <div style="font-size: 0.9em; color: #374151; margin-bottom: 10px">
              Program dijalankan:
              <code>./bilinear &lt;file&gt; [scale]</code> (default scale 2.0,
              mengikuti slider di UI). Cuplikan ini sinkron dengan
              <code>bilinear_serial_parallel.c</code>.
            </div>

            <h5 style="margin: 10px 0; color: #334155">
              1) bilinear_interpolate
            </h5>
            <pre
              style="
                background: #0f172a;
                color: #e5e7eb;
                padding: 12px;
                border-radius: 8px;
                overflow-x: auto;
                font-size: 13px;
                line-height: 1.5;
                border: 1px solid #1f2937;
              "
            ><code>static inline double bilinear_interpolate(double x, double y,
    double Q11, double Q21, double Q12, double Q22) {
  double fx1 = Q11 + (Q21 - Q11) * x;
  double fx2 = Q12 + (Q22 - Q12) * x;
  return fx1 + (fx2 - fx1) * y;
}</code></pre>
            <div style="font-size: 0.85em; color: #4b5563; margin-bottom: 12px">
              Menggabungkan 4 tetangga (Q11, Q21, Q12, Q22) dengan fraksi jarak
              x,y (fx, fy).
            </div>

            <h5 style="margin: 10px 0; color: #334155">
              2) bilinear_resize_serial
            </h5>
            <pre
              style="
                background: #0f172a;
                color: #e5e7eb;
                padding: 12px;
                border-radius: 8px;
                overflow-x: auto;
                font-size: 13px;
                line-height: 1.5;
                border: 1px solid #1f2937;
              "
            ><code>unsigned char** bilinear_resize_serial(
    unsigned char** src, int src_h, int src_w,
    int new_h, int new_w) {
  unsigned char** dst = malloc(new_h * sizeof(unsigned char*));
  for (int i = 0; i < new_h; i++) dst[i] = malloc(new_w * 3);

  double rx = (double)(src_w - 1) / (new_w - 1);
  double ry = (double)(src_h - 1) / (new_h - 1);

  for (int i = 0; i < new_h; i++) {
    for (int j = 0; j < new_w; j++) {
      double sx = j * rx, sy = i * ry;
      int x1 = (int)sx, y1 = (int)sy;
      if (x1 >= src_w - 1) x1 = src_w - 2;
      if (y1 >= src_h - 1) y1 = src_h - 2;
      int x2 = x1 + 1, y2 = y1 + 1;
      double dx = sx - x1, dy = sy - y1;
      for (int c = 0; c < 3; c++) {
        double Q11 = src[y1][x1 * 3 + c], Q21 = src[y1][x2 * 3 + c];
        double Q12 = src[y2][x1 * 3 + c], Q22 = src[y2][x2 * 3 + c];
        double val = bilinear_interpolate(dx, dy, Q11, Q21, Q12, Q22);
        dst[i][j * 3 + c] = (unsigned char)(val + 0.5);
      }
    }
  }
  return dst;
}</code></pre>
            <div style="font-size: 0.85em; color: #4b5563; margin-bottom: 12px">
              Loop baris-kolom: mapping dest‚Üísrc, clamp batas, hitung dx/dy,
              lalu blend per channel RGB menggunakan 4 tetangga.
            </div>

            <h5 style="margin: 10px 0; color: #334155">
              3) bilinear_resize_parallel (OpenMP)
            </h5>
            <pre
              style="
                background: #0f172a;
                color: #e5e7eb;
                padding: 12px;
                border-radius: 8px;
                overflow-x: auto;
                font-size: 13px;
                line-height: 1.5;
                border: 1px solid #1f2937;
              "
            ><code>unsigned char** bilinear_resize_parallel(
    unsigned char** src, int src_h, int src_w,
    int new_h, int new_w, int threads) {
  unsigned char** dst = malloc(new_h * sizeof(unsigned char*));
  for (int i = 0; i < new_h; i++) dst[i] = malloc(new_w * 3);

  double rx = (double)(src_w - 1) / (new_w - 1);
  double ry = (double)(src_h - 1) / (new_h - 1);

  omp_set_num_threads(threads);
  #pragma omp parallel for collapse(2) schedule(dynamic)
  for (int i = 0; i < new_h; i++) {
    for (int j = 0; j < new_w; j++) {
      double sx = j * rx, sy = i * ry;
      int x1 = (int)sx, y1 = (int)sy;
      if (x1 >= src_w - 1) x1 = src_w - 2;
      if (y1 >= src_h - 1) y1 = src_h - 2;
      int x2 = x1 + 1, y2 = y1 + 1;
      double dx = sx - x1, dy = sy - y1;
      for (int c = 0; c < 3; c++) {
        double Q11 = src[y1][x1 * 3 + c], Q21 = src[y1][x2 * 3 + c];
        double Q12 = src[y2][x1 * 3 + c], Q22 = src[y2][x2 * 3 + c];
        double val = bilinear_interpolate(dx, dy, Q11, Q21, Q12, Q22);
        dst[i][j * 3 + c] = (unsigned char)(val + 0.5);
      }
    }
  }
  return dst;
}</code></pre>
            <div style="font-size: 0.85em; color: #4b5563">
              Sama seperti serial, tetapi loop baris-kolom di-parallel-kan
              dengan OpenMP (<code>collapse(2)</code>,
              <code>schedule(dynamic)</code>) dan jumlah thread diatur via
              <code>omp_set_num_threads</code>.
            </div>
          </div>
        </details>

        <div
          style="
            margin-top: 25px;
            padding: 20px;
            background: #fff3cd;
            border-radius: 10px;
            border-left: 5px solid #ffc107;
          "
        >
          <h3 style="color: #856404; margin-bottom: 10px">üìö How It Works</h3>
          <p style="color: #333; line-height: 1.8; margin-bottom: 10px">
            <strong>1. Read PNG Image</strong> - Load original image via
            ImageMagick<br />
            <strong>2. Bilinear Interpolation</strong> - For each new pixel,
            interpolate from 4 nearest neighbors<br />
            <strong>3. Serial vs Parallel</strong> - Compare performance between
            single-threaded and multi-threaded versions<br />
            <strong>4. Memory-Bound Algorithm</strong> - Speedup limited by
            memory bandwidth, not CPU cores<br />
            <strong>5. Output</strong> - Save upscaled image as PPM/PNG
          </p>
        </div>
      </div>
    </div>

    <script>
      // ==================== FIBONACCI dengan C BACKEND ====================
      function formatSpeedup(speed) {
        const val = Number(speed);
        if (!isFinite(val) || val <= 0) {
          return { text: "slower", isFaster: false };
        }
        if (val >= 1) {
          return { text: `${val.toFixed(2)}x faster`, isFaster: true };
        }
        const slower = (1 / val).toFixed(2);
        return { text: `${slower}x slower`, isFaster: false };
      }

      async function calculateFibonacci() {
        const n = parseInt(document.getElementById("fibN").value);
        const mode = "both";
        const output = document.getElementById("fibOutput");
        const results = document.getElementById("fibResults");
        const btn = document.getElementById("calculateBtn");

        // Validasi input
        if (isNaN(n) || n < 0 || n > 45) {
          output.innerHTML =
            '<div class="error">‚ùå Invalid input. N must be between 0 and 45</div>';
          results.style.display = "block";
          return;
        }

        // Show loading
        btn.disabled = true;
        btn.textContent = "Running OpenMP + OpenCilk...";
        output.innerHTML = '<div class="loading">Executing C program</div>';
        results.style.display = "block";

        try {
          // Call C backend via Node.js API with mode parameter
          const response = await fetch(
            `http://localhost:3000/api/fibonacci/${n}?mode=${mode}`
          );

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();

          // Display results
          displayFibonacciResults(data);
        } catch (error) {
          output.innerHTML = `
            <div class="error">
              <strong>‚ùå Error connecting to C backend:</strong><br>
              ${error.message}<br><br>
              <strong>Make sure the server is running:</strong><br>
              <code>npm start</code>
            </div>
          `;
        } finally {
          btn.disabled = false;
          btn.textContent = "Calculate OpenMP + OpenCilk (C Backend)";
        }
      }

      function displayFibonacciResults(data) {
        const output = document.getElementById("fibOutput");
        let html = "";

        // Sequential
        html += `
          <div class="result-item">
            <div class="result-label">1. Pure Sequential (Baseline) <span class="c-badge">C</span></div>
            <div class="result-details">
              <div class="detail-item">
                <div class="detail-label">Result</div>
                <div class="detail-value">${data.sequential.result}</div>
              </div>
              <div class="detail-item">
                <div class="detail-label">Time</div>
                <div class="detail-value">${(
                  data.sequential.time * 1000
                ).toFixed(3)} ms</div>
              </div>
              <div class="detail-item">
                <div class="detail-label">Speedup</div>
                <div class="detail-value">${data.sequential.speedup}x</div>
              </div>
              <div class="detail-item">
                <div class="detail-label">Efficiency</div>
                <div class="detail-value">${data.sequential.efficiency}%</div>
              </div>
            </div>
          </div>
        `;

        // OpenMP Parallel (if available)
        if (data.openmp_parallel) {
          html += `
            <div class="result-item" style="border-left: 4px solid #28a745;">
              <div class="result-label">2. OpenMP Parallel (Task-Based) <span class="openmp-badge">OpenMP</span></div>
              <div class="result-details">
                <div class="detail-item">
                  <div class="detail-label">Result</div>
                  <div class="detail-value">${data.openmp_parallel.result}</div>
                </div>
                <div class="detail-item">
                  <div class="detail-label">Time</div>
                  <div class="detail-value">${(
                    data.openmp_parallel.time * 1000
                  ).toFixed(3)} ms</div>
                </div>
                <div class="detail-item">
                  <div class="detail-label">Speedup</div>
                  <div class="detail-value" style="color:${
                    formatSpeedup(data.openmp_parallel.speedup).isFaster
                      ? "#28a745"
                      : "#dc3545"
                  };">${formatSpeedup(data.openmp_parallel.speedup).text}${
            formatSpeedup(data.openmp_parallel.speedup).isFaster ? " ‚ö°" : ""
          }</div>
                </div>
                <div class="detail-item">
                  <div class="detail-label">Efficiency</div>
                  <div class="detail-value">${data.openmp_parallel.efficiency.toFixed(
                    2
                  )}%</div>
                </div>
                <div class="detail-item">
                  <div class="detail-label">Threads</div>
                  <div class="detail-value">${data.num_threads}</div>
                </div>
                <div class="detail-item">
                  <div class="detail-label">Cutoff</div>
                  <div class="detail-value">${data.openmp_parallel.cutoff}</div>
                </div>
                <div class="detail-item">
                  <div class="detail-label">Model</div>
                  <div class="detail-value" style="font-size: 11px;">${
                    data.openmp_parallel.model
                  }</div>
                </div>
              </div>
            </div>
          `;
        }

        // Cilk Parallel (if available)
        if (data.cilk_parallel) {
          html += `
            <div class="result-item" style="border-left: 4px solid #ff6b6b;">
              <div class="result-label">3. Cilk Parallel (Work-Stealing) <span class="cilk-badge">Cilk</span></div>
              <div class="result-details">
                <div class="detail-item">
                  <div class="detail-label">Result</div>
                  <div class="detail-value">${data.cilk_parallel.result}</div>
                </div>
                <div class="detail-item">
                  <div class="detail-label">Time</div>
                  <div class="detail-value">${(
                    data.cilk_parallel.time * 1000
                  ).toFixed(3)} ms</div>
                </div>
                <div class="detail-item">
                  <div class="detail-label">Speedup</div>
                  <div class="detail-value" style="color:${
                    formatSpeedup(data.cilk_parallel.speedup).isFaster
                      ? "#ff6b6b"
                      : "#dc3545"
                  };">${formatSpeedup(data.cilk_parallel.speedup).text}${
            formatSpeedup(data.cilk_parallel.speedup).isFaster ? " ‚ö°" : ""
          }</div>
                </div>
                <div class="detail-item">
                  <div class="detail-label">Cutoff</div>
                  <div class="detail-value">${data.cilk_parallel.cutoff}</div>
                </div>
                <div class="detail-item">
                  <div class="detail-label">Model</div>
                  <div class="detail-value" style="font-size: 11px;">${
                    data.cilk_parallel.model
                  }</div>
                </div>
              </div>
            </div>
          `;
        }

        // Summary
        const candidates = [];
        if (data.openmp_parallel) {
          candidates.push({
            name: "OpenMP Parallel",
            time: data.openmp_parallel.time,
            speedup: data.openmp_parallel.speedup,
            result: data.openmp_parallel.result,
          });
        }
        if (data.cilk_parallel) {
          candidates.push({
            name: "Cilk Parallel",
            time: data.cilk_parallel.time,
            speedup: data.cilk_parallel.speedup,
            result: data.cilk_parallel.result,
          });
        }
        if (candidates.length > 0) {
          candidates.sort((a, b) => a.time - b.time);
          const best = candidates[0];
          const improvementRaw =
            ((data.sequential.time - best.time) / data.sequential.time) * 100;
          const improvement = improvementRaw.toFixed(1);
          const speedInfo = formatSpeedup(best.speedup);
          html += `
            <div class="info-box" style="background: ${
              speedInfo.isFaster ? "#d4edda" : "#f8d7da"
            }; border-left-color: ${
            speedInfo.isFaster ? "#28a745" : "#dc3545"
          }; margin-top: 15px;">
              <strong style="color: ${
                speedInfo.isFaster ? "#155724" : "#721c24"
              };">üìä Performance Summary:</strong><br>
              ${best.name} is <strong>${
            speedInfo.text
          }</strong> than Sequential.<br>
              Time delta: <strong>${improvement}%</strong> (${(
            (data.sequential.time - best.time) *
            1000
          ).toFixed(2)} ms)<br>
              Computed Fibonacci(${data.n}) = <strong>${best.result}</strong>
            </div>
          `;
        }

        output.innerHTML = html;
      }

      // ==================== BILINEAR INTERPOLATION C BACKEND ====================

      let imageMetadata = {
        width: 400,
        height: 264,
      };

      function updateImageInfo() {
        const imageFile = document.getElementById("imageFile").value;
        if (imageFile === "custom") {
          document.getElementById("customImagePath").style.display = "block";
        } else {
          document.getElementById("customImagePath").style.display = "none";
        }
        updateScalingInfo();
      }

      function updateScalingInfo() {
        const scaling = parseFloat(
          document.getElementById("scalingFactor").value
        );
        document.getElementById("scalingVal").textContent = scaling.toFixed(1);

        const newWidth = Math.round(imageMetadata.width * scaling);
        const newHeight = Math.round(imageMetadata.height * scaling);

        document.getElementById("origWidth").textContent = imageMetadata.width;
        document.getElementById("origHeight").textContent =
          imageMetadata.height;
        document.getElementById("newWidth").textContent = newWidth;
        document.getElementById("newHeight").textContent = newHeight;
        document.getElementById("estimatedTime").textContent = (
          ((newWidth * newHeight) / 1000000) *
          5
        ).toFixed(1);

        document.getElementById("imageInfo").style.display = "block";
      }

      async function processImageBilinear() {
        const scaling = parseFloat(
          document.getElementById("scalingFactor").value
        );
        const imageFile =
          document.getElementById("imageFile").value === "custom"
            ? document.getElementById("customImagePath").value
            : "gantrycrane.png";

        // Run both serial and parallel automatically
        await runBilinearProcess(imageFile, scaling, "both");
      }

      async function runBilinearProcess(imageFile, scaling, mode) {
        const output = document.getElementById("bilinearOutput");
        const results = document.getElementById("bilinearResults");
        const processBtn = document.getElementById("processBtn");

        processBtn.disabled = true;
        output.innerHTML =
          '<div class="loading">Processing image with C backend (Serial & Parallel)</div>';
        results.style.display = "block";

        try {
          // Call C backend to process bilinear interpolation (Serial & Parallel)
          const response = await fetch(
            `http://localhost:3000/api/bilinear?image=${encodeURIComponent(
              imageFile
            )}&scaling=${scaling}&mode=both`
          );

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();

          // Update metadata
          imageMetadata.width = data.original_width;
          imageMetadata.height = data.original_height;

          // Display results
          displayBilinearResults(data, mode);

          // Show image comparison
          showImageComparison(data);
        } catch (error) {
          output.innerHTML = `
            <div class="error">
              <strong>‚ùå Error processing image:</strong><br>
              ${error.message}<br><br>
              <strong>Make sure:</strong><br>
              1. Server is running: <code>npm start</code><br>
              2. Image file exists: <code>${imageFile}</code><br>
              3. ImageMagick installed: <code>brew install imagemagick</code>
            </div>
          `;
        } finally {
          processBtn.disabled = false;
        }
      }

      function displayBilinearResults(data, mode) {
        const output = document.getElementById("bilinearOutput");
        let html = "";

        html += `
          <div class="result-item">
            <div class="result-label">Image Processing Results <span class="c-badge">C</span> <span class="openmp-badge">OpenMP</span></div>
            <div class="result-details">
              <div class="detail-item">
                <div class="detail-label">Original Size</div>
                <div class="detail-value">${data.original_width}√ó${
          data.original_height
        }</div>
              </div>
              <div class="detail-item">
                <div class="detail-label">Upscaled Size</div>
                <div class="detail-value">${data.new_width}√ó${
          data.new_height
        }</div>
              </div>
              <div class="detail-item">
                <div class="detail-label">Scaling Factor</div>
                <div class="detail-value">${data.scaling}x</div>
              </div>
              <div class="detail-item">
                <div class="detail-label">Total Pixels</div>
                <div class="detail-value">${(
                  (data.new_width * data.new_height) /
                  1000000
                ).toFixed(2)}M</div>
              </div>
            </div>
          </div>
        `;

        // Serial result
        html += `
          <div class="result-item">
            <div class="result-label">Serial Processing (Baseline) <span class="c-badge">C Serial</span></div>
            <div class="result-details">
              <div class="detail-item">
                <div class="detail-label">Execution Time</div>
                <div class="detail-value">${(data.serial_time * 1000).toFixed(
                  3
                )} ms</div>
              </div>
              <div class="detail-item">
                <div class="detail-label">Throughput</div>
                <div class="detail-value">${(
                  (data.new_width * data.new_height) /
                  data.serial_time /
                  1000000
                ).toFixed(2)} Mpixels/s</div>
              </div>
            </div>
          </div>
        `;

        // Parallel results
        if (data.parallel_results) {
          data.parallel_results.forEach((result) => {
            const speedup = data.serial_time / result.time;
            const efficiency = ((speedup / result.threads) * 100).toFixed(2);

            html += `
              <div class="result-item" style="border-left: 4px solid #28a745;">
                <div class="result-label">${
                  result.threads
                }-Thread Parallel <span class="openmp-badge">OpenMP</span></div>
                <div class="result-details">
                  <div class="detail-item">
                    <div class="detail-label">Execution Time</div>
                    <div class="detail-value">${(result.time * 1000).toFixed(
                      3
                    )} ms</div>
                  </div>
                  <div class="detail-item">
                    <div class="detail-label">Speedup</div>
                    <div class="detail-value" style="color:${
                      formatSpeedup(speedup).isFaster ? "#28a745" : "#dc3545"
                    };">${formatSpeedup(speedup).text}</div>
                  </div>
                  <div class="detail-item">
                    <div class="detail-label">Efficiency</div>
                    <div class="detail-value">${efficiency}%</div>
                  </div>
                  <div class="detail-item">
                    <div class="detail-label">Throughput</div>
                    <div class="detail-value">${(
                      (data.new_width * data.new_height) /
                      result.time /
                      1000000
                    ).toFixed(2)} Mpixels/s</div>
                  </div>
                </div>
              </div>
            `;
          });
        }

        // Summary
        html += `
          <div class="info-box" style="background: #e7d4f5; border-left-color: #7b42bc; margin-top: 15px;">
            <strong style="color: #4a148c;">üí° Memory-Bound Algorithm:</strong><br>
            Bilinear interpolation is <strong>memory-bound</strong>, not compute-bound.<br>
            Speedup limited by memory bandwidth, not number of CPU cores.<br>
            This is why parallel versions may show low efficiency on small images.
          </div>
        `;

        output.innerHTML = html;
      }

      function showImageComparison(data) {
        const comparison = document.getElementById("imageComparison");
        const originalImg = document.getElementById("originalImg");
        const upscaledImgSerial = document.getElementById("upscaledImgSerial");
        const upscaledImgParallel = document.getElementById(
          "upscaledImgParallel"
        );

        const origSizeEl = document.getElementById("origSize");
        const serialTimeEl = document.getElementById("serialTime");
        const parallelTimeEl = document.getElementById("parallelTime");

        // Load original image
        const origFile = data.original_file || "gantrycrane.png";
        originalImg.src = origFile;
        originalImg.onerror = () => {
          console.error("Failed to load original image:", origFile);
          origSizeEl.textContent = "‚ùå Image not found";
        };
        origSizeEl.textContent = `${data.original_width}√ó${data.original_height} px`;

        // Load serial result
        const serialFile =
          data.output_file_serial || data.output_file || "result_serial.png";
        upscaledImgSerial.src = serialFile;
        upscaledImgSerial.onerror = () => {
          console.error("Failed to load serial image:", serialFile);
          serialTimeEl.textContent = "‚ùå Image not found";
        };
        serialTimeEl.textContent = `Serial: ${data.new_width}√ó${
          data.new_height
        } px, ${(data.serial_time * 1000).toFixed(2)} ms`;

        // Load parallel result (8 threads)
        const parallelFile =
          data.output_file_parallel || data.output_file || "result_serial.png";
        upscaledImgParallel.src = parallelFile;
        upscaledImgParallel.onerror = () => {
          console.error("Failed to load parallel image:", parallelFile);
          parallelTimeEl.textContent = "‚ùå Image not found";
        };

        if (data.parallel_results && data.parallel_results.length > 0) {
          const parallelResult =
            data.parallel_results[data.parallel_results.length - 1]; // Get 8-thread result
          parallelTimeEl.textContent = `Parallel (${
            parallelResult.threads
          }T): ${data.new_width}√ó${data.new_height} px, ${(
            parallelResult.time * 1000
          ).toFixed(2)} ms`;
        }

        comparison.style.display = "grid";
      }
    </script>
  </body>
</html>
